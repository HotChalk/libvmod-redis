varnishtest "Tests handling of MOVED reply messages"

server s1 {
   rxreq
   txresp
} -repeat 3 -start

varnish v1 -vcl+backend {
    import redis from "${vmod_topbuild}/src/.libs/libvmod_redis.so";

    sub vcl_init {
        new db = redis.db("${redis_master1}", 500, 0, 0, 0, true, 32, true, 16);
        db.add_server("${redis_master2}");
        db.add_server("${redis_master3}");
    }

    sub vcl_deliver {
        # Set key in master1.
        db.command("SET");
        db.push("${redis_key_in_master1}");
        db.push("hello");
        db.execute();
        if (db.reply_is_status()) {
            set resp.http.Reply-1 = db.get_status_reply();
        }
    }
} -start

client c1 {
    txreq
    rxresp

    expect resp.http.Reply-1 == "OK"
} -run

varnish v2 -vcl+backend {
    import redis from "${vmod_topbuild}/src/.libs/libvmod_redis.so";

    sub vcl_init {
        new master1 = redis.db("${redis_master1}", 500, 0, 0, 0, false, 1, false, 0);
        new master2 = redis.db("${redis_master2}", 500, 0, 0, 0, false, 1, false, 0);
    }

    sub vcl_deliver {
        # Get the key's containing slot.
        master1.command("CLUSTER");
        master1.push("KEYSLOT");
        master1.push("${redis_key_in_master1}");
        master1.execute();
        if (master1.reply_is_integer()) {
            set resp.http.Slot = master1.get_integer_reply();
        }

        # Get the ID for the original node (master1).
        master1.command("CLUSTER");
        master1.push("NODES");
        master1.execute();
        if (master1.reply_is_string()) {
            set resp.http.NodeOrig = regsub(master1.get_reply(), "(?s)^(?:.+\n)?([0-9a-f]+) ${redis_master1} .*$", "\1");
            if (resp.http.NodeOrig !~ "[0-9a-f]+") {
                unset resp.http.NodeOrig;
            }
        }

        # Get the ID for the destination node (master2).
        master1.command("CLUSTER");
        master1.push("NODES");
        master1.execute();
        if (master1.reply_is_string()) {
            set resp.http.NodeDest = regsub(master1.get_reply(), "(?s)^(?:.+\n)?([0-9a-f]+) ${redis_master2} .*$", "\1");
            if (resp.http.NodeDest !~ "[0-9a-f]+") {
                unset resp.http.NodeDest;
            }
        }

        # Mark the destination node as IMPORTING.
        master2.command("CLUSTER");
        master2.push("SETSLOT");
        master2.push(resp.http.Slot);
        master2.push("IMPORTING");
        master2.push(resp.http.NodeOrig);
        master2.execute();
        if (master2.reply_is_status()) {
            set resp.http.Reply-4 = master2.get_status_reply();
        }

        # Mark the original node as MIGRATING.
        master1.command("CLUSTER");
        master1.push("SETSLOT");
        master1.push(resp.http.Slot);
        master1.push("MIGRATING");
        master1.push(resp.http.NodeDest);
        master1.execute();
        if (master1.reply_is_status()) {
            set resp.http.Reply-5 = master1.get_status_reply();
        }

        # Migrate key.
        master1.command("MIGRATE");
        master1.push(regsub("${redis_master2}", "([\d\.]*):([\d]*)", "\1"));
        master1.push(regsub("${redis_master2}", "([\d\.]*):([\d]*)", "\2"));
        master1.push("${redis_key_in_master1}");
        master1.push("0");
        master1.push("0");
        master1.execute();
        if (master1.reply_is_status()) {
            set resp.http.Reply-6 = master1.get_status_reply();
        }

        # Assign the containing slot to the destination node in both nodes.

        master1.command("CLUSTER");
        master1.push("SETSLOT");
        master1.push(resp.http.Slot);
        master1.push("NODE");
        master1.push(resp.http.NodeDest);
        master1.execute();
        if (master1.reply_is_status()) {
            set resp.http.Reply-7 = master1.get_status_reply();
        }

        master2.command("CLUSTER");
        master2.push("SETSLOT");
        master2.push(resp.http.Slot);
        master2.push("NODE");
        master2.push(resp.http.NodeDest);
        master2.execute();
        if (master2.reply_is_status()) {
            set resp.http.Reply-8 = master2.get_status_reply();
        }

        # Check that the original node replies with a MOVED redirection.
        master1.command("GET");
        master1.push("${redis_key_in_master1}");
        master1.execute();
        if (master1.reply_is_error()) {
            if (master1.get_error_reply() ~ "^MOVED ") {
                set resp.http.Reply-9 = "MOVED";
            }
        }
    }
} -start

client c2 -connect ${v2_sock} {
    txreq
    rxresp

    expect resp.http.Slot != <undef>

    expect resp.http.NodeOrig != <undef>

    expect resp.http.NodeDest != <undef>

    expect resp.http.Reply-4 == "OK"

    expect resp.http.Reply-5 == "OK"

    expect resp.http.Reply-6 == "OK"

    expect resp.http.Reply-7 == "OK"

    expect resp.http.Reply-8 == "OK"

    expect resp.http.Reply-9 == "MOVED"
} -run

varnish v3 -vcl+backend {
    import redis from "${vmod_topbuild}/src/.libs/libvmod_redis.so";

    sub vcl_init {
        new db = redis.db("${redis_master1}", 500, 0, 0, 0, true, 32, true, 16);
        db.add_server("${redis_master2}");
        db.add_server("${redis_master3}");
    }

    sub vcl_deliver {
        # Get the key (should internally handle the MOVED redirection).
        db.command("GET");
        db.push("${redis_key_in_master1}");
        db.execute();
        if (db.reply_is_string()) {
            set resp.http.Reply-10 = db.get_string_reply();
        }
    }
} -start

client c3 -connect ${v3_sock} {
    txreq
    rxresp

    expect resp.http.Reply-10 == "hello"
} -run

varnish v1 -expect client_req == 1
varnish v2 -expect client_req == 1
varnish v3 -expect client_req == 1
